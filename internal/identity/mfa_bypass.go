// Package identity - Admin-generated MFA Bypass Codes
package identity

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// MFABypassCode represents an admin-generated bypass code
type MFABypassCode struct {
	ID           string     `json:"id"`
	UserID       string     `json:"user_id"`
	UserEmail    string     `json:"user_email,omitempty"`
	Code         string     `json:"code,omitempty"` // Only returned on creation
	Reason       string     `json:"reason"`
	GeneratedBy  string     `json:"generated_by"`
	GeneratorEmail string   `json:"generator_email,omitempty"`
	ValidFrom    time.Time  `json:"valid_from"`
	ValidUntil   time.Time  `json:"valid_until"`
	MaxUses      int        `json:"max_uses"`
	UseCount     int        `json:"use_count"`
	Status       string     `json:"status"` // active, used, expired, revoked
	UsedAt       *time.Time `json:"used_at,omitempty"`
	UsedFromIP   string     `json:"used_from_ip,omitempty"`
	RevokedAt    *time.Time `json:"revoked_at,omitempty"`
	RevokedBy    *string    `json:"revoked_by,omitempty"`
	CreatedAt    time.Time  `json:"created_at"`
}

// MFABypassAuditEntry represents an audit log entry
type MFABypassAuditEntry struct {
	ID           string                 `json:"id"`
	BypassCodeID *string                `json:"bypass_code_id,omitempty"`
	UserID       *string                `json:"user_id,omitempty"`
	Action       string                 `json:"action"`
	PerformedBy  *string                `json:"performed_by,omitempty"`
	IPAddress    string                 `json:"ip_address,omitempty"`
	UserAgent    string                 `json:"user_agent,omitempty"`
	Details      map[string]interface{} `json:"details,omitempty"`
	CreatedAt    time.Time              `json:"created_at"`
}

// GenerateBypassCodeRequest for creating a bypass code
type GenerateBypassCodeRequest struct {
	UserID       string `json:"user_id"`
	Reason       string `json:"reason"`
	ValidHours   int    `json:"valid_hours"`   // How long the code is valid (default 24)
	MaxUses      int    `json:"max_uses"`      // Max times code can be used (default 1)
}

// GenerateMFABypassCode creates a new bypass code for a user
func (s *Service) GenerateMFABypassCode(ctx context.Context, req *GenerateBypassCodeRequest, adminID, adminIP string) (*MFABypassCode, error) {
	if req.UserID == "" {
		return nil, errors.New("user_id is required")
	}
	if req.Reason == "" {
		return nil, errors.New("reason is required")
	}

	// Verify user exists
	var userEmail string
	err := s.db.Pool.QueryRow(ctx, "SELECT email FROM users WHERE id = $1", req.UserID).Scan(&userEmail)
	if err != nil {
		return nil, errors.New("user not found")
	}

	// Generate secure bypass code (16 characters)
	codeBytes := make([]byte, 12)
	if _, err := rand.Read(codeBytes); err != nil {
		return nil, err
	}
	code := base64.URLEncoding.EncodeToString(codeBytes)[:16]

	// Hash the code
	codeHash, err := bcrypt.GenerateFromPassword([]byte(code), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Set defaults
	validHours := req.ValidHours
	if validHours <= 0 {
		validHours = 24
	}
	maxUses := req.MaxUses
	if maxUses <= 0 {
		maxUses = 1
	}

	validFrom := time.Now()
	validUntil := validFrom.Add(time.Duration(validHours) * time.Hour)

	bypassID := uuid.New().String()

	// Create bypass code
	query := `
		INSERT INTO mfa_bypass_codes (
			id, user_id, code_hash, reason, generated_by,
			valid_from, valid_until, max_uses, use_count, status, created_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 0, 'active', NOW())
		RETURNING created_at
	`

	var createdAt time.Time
	err = s.db.Pool.QueryRow(ctx, query,
		bypassID, req.UserID, string(codeHash), req.Reason, adminID,
		validFrom, validUntil, maxUses,
	).Scan(&createdAt)
	if err != nil {
		return nil, err
	}

	// Log audit event
	s.logBypassAudit(ctx, bypassID, req.UserID, "generated", &adminID, adminIP, "", map[string]interface{}{
		"reason":      req.Reason,
		"valid_hours": validHours,
		"max_uses":    maxUses,
	})

	return &MFABypassCode{
		ID:          bypassID,
		UserID:      req.UserID,
		UserEmail:   userEmail,
		Code:        code, // Return plain code only on creation
		Reason:      req.Reason,
		GeneratedBy: adminID,
		ValidFrom:   validFrom,
		ValidUntil:  validUntil,
		MaxUses:     maxUses,
		UseCount:    0,
		Status:      "active",
		CreatedAt:   createdAt,
	}, nil
}

// VerifyBypassCode verifies and uses a bypass code
func (s *Service) VerifyBypassCode(ctx context.Context, userID, code, ipAddress, userAgent string) (bool, error) {
	// Get active bypass codes for user
	query := `
		SELECT id, code_hash, valid_until, max_uses, use_count
		FROM mfa_bypass_codes
		WHERE user_id = $1 AND status = 'active'
		ORDER BY created_at DESC
	`

	rows, err := s.db.Pool.Query(ctx, query, userID)
	if err != nil {
		return false, err
	}
	defer rows.Close()

	for rows.Next() {
		var bypassID, codeHash string
		var validUntil time.Time
		var maxUses, useCount int

		if err := rows.Scan(&bypassID, &codeHash, &validUntil, &maxUses, &useCount); err != nil {
			continue
		}

		// Check expiration
		if time.Now().After(validUntil) {
			s.db.Pool.Exec(ctx, "UPDATE mfa_bypass_codes SET status = 'expired' WHERE id = $1", bypassID)
			continue
		}

		// Check max uses
		if maxUses > 0 && useCount >= maxUses {
			s.db.Pool.Exec(ctx, "UPDATE mfa_bypass_codes SET status = 'used' WHERE id = $1", bypassID)
			continue
		}

		// Verify code
		if err := bcrypt.CompareHashAndPassword([]byte(codeHash), []byte(code)); err != nil {
			continue // Try next code
		}

		// Code is valid - update usage
		newUseCount := useCount + 1
		newStatus := "active"
		if maxUses > 0 && newUseCount >= maxUses {
			newStatus = "used"
		}

		_, err = s.db.Pool.Exec(ctx,
			`UPDATE mfa_bypass_codes
			SET use_count = $1, status = $2, used_at = NOW(), used_from_ip = $3
			WHERE id = $4`,
			newUseCount, newStatus, ipAddress, bypassID,
		)
		if err != nil {
			return false, err
		}

		// Log audit
		s.logBypassAudit(ctx, bypassID, userID, "used", nil, ipAddress, userAgent, nil)

		return true, nil
	}

	return false, nil
}

// ListBypassCodes returns bypass codes with filtering
func (s *Service) ListBypassCodes(ctx context.Context, userID, status string, activeOnly bool, limit, offset int) ([]MFABypassCode, int, error) {
	if limit <= 0 {
		limit = 50
	}

	// Build query conditions with parameterized queries
	conditions := "1=1"
	args := []interface{}{}
	argIdx := 1

	if userID != "" {
		conditions += fmt.Sprintf(" AND bc.user_id::text = $%d", argIdx)
		args = append(args, userID)
		argIdx++
	}
	if status != "" {
		conditions += fmt.Sprintf(" AND bc.status = $%d", argIdx)
		args = append(args, status)
		argIdx++
	}
	if activeOnly {
		conditions += " AND bc.status = 'active' AND bc.valid_until > NOW() AND (bc.max_uses IS NULL OR bc.use_count < bc.max_uses)"
	}

	// Count total
	var total int
	s.db.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM mfa_bypass_codes bc WHERE "+conditions, args...).Scan(&total)

	// Get codes
	query := fmt.Sprintf(`
		SELECT bc.id, bc.user_id, u.email, bc.reason, bc.generated_by, g.email,
			bc.valid_from, bc.valid_until, bc.max_uses, bc.use_count, bc.status,
			bc.used_at, bc.used_from_ip, bc.revoked_at, bc.revoked_by, bc.created_at
		FROM mfa_bypass_codes bc
		JOIN users u ON bc.user_id = u.id
		JOIN users g ON bc.generated_by = g.id
		WHERE %s
		ORDER BY bc.created_at DESC
		LIMIT $%d OFFSET $%d
	`, conditions, argIdx, argIdx+1)

	queryArgs := append(args, limit, offset)
	rows, err := s.db.Pool.Query(ctx, query, queryArgs...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var codes []MFABypassCode
	for rows.Next() {
		var c MFABypassCode
		err := rows.Scan(
			&c.ID, &c.UserID, &c.UserEmail, &c.Reason, &c.GeneratedBy, &c.GeneratorEmail,
			&c.ValidFrom, &c.ValidUntil, &c.MaxUses, &c.UseCount, &c.Status,
			&c.UsedAt, &c.UsedFromIP, &c.RevokedAt, &c.RevokedBy, &c.CreatedAt,
		)
		if err != nil {
			continue
		}
		codes = append(codes, c)
	}

	return codes, total, nil
}

// RevokeBypassCode revokes an active bypass code
func (s *Service) RevokeBypassCode(ctx context.Context, bypassID, adminID, ipAddress string) error {
	var status, userID string
	err := s.db.Pool.QueryRow(ctx,
		"SELECT status, user_id FROM mfa_bypass_codes WHERE id = $1",
		bypassID,
	).Scan(&status, &userID)
	if err != nil {
		return errors.New("bypass code not found")
	}

	if status != "active" {
		return errors.New("bypass code is not active")
	}

	_, err = s.db.Pool.Exec(ctx,
		`UPDATE mfa_bypass_codes
		SET status = 'revoked', revoked_at = NOW(), revoked_by = $1
		WHERE id = $2`,
		adminID, bypassID,
	)
	if err != nil {
		return err
	}

	s.logBypassAudit(ctx, bypassID, userID, "revoked", &adminID, ipAddress, "", nil)

	return nil
}

// RevokeAllBypassCodes revokes all active codes for a user
func (s *Service) RevokeAllBypassCodes(ctx context.Context, userID, adminID, ipAddress string) (int, error) {
	result, err := s.db.Pool.Exec(ctx,
		`UPDATE mfa_bypass_codes
		SET status = 'revoked', revoked_at = NOW(), revoked_by = $1
		WHERE user_id = $2 AND status = 'active'`,
		adminID, userID,
	)
	if err != nil {
		return 0, err
	}

	count := int(result.RowsAffected())
	if count > 0 {
		s.logBypassAudit(ctx, "", userID, "revoked_all", &adminID, ipAddress, "", map[string]interface{}{
			"count": count,
		})
	}

	return count, nil
}

// GetBypassAuditLog returns audit log for bypass codes
func (s *Service) GetBypassAuditLog(ctx context.Context, userID string, limit, offset int) ([]MFABypassAuditEntry, error) {
	if limit <= 0 {
		limit = 100
	}

	query := `
		SELECT id, bypass_code_id, user_id, action, performed_by, ip_address, user_agent, details, created_at
		FROM mfa_bypass_audit
		WHERE ($1 = '' OR user_id::text = $1)
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3
	`

	rows, err := s.db.Pool.Query(ctx, query, userID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entries []MFABypassAuditEntry
	for rows.Next() {
		var e MFABypassAuditEntry
		err := rows.Scan(&e.ID, &e.BypassCodeID, &e.UserID, &e.Action, &e.PerformedBy,
			&e.IPAddress, &e.UserAgent, &e.Details, &e.CreatedAt)
		if err != nil {
			continue
		}
		entries = append(entries, e)
	}

	return entries, nil
}

// ExpireOldBypassCodes marks expired codes
func (s *Service) ExpireOldBypassCodes(ctx context.Context) (int, error) {
	result, err := s.db.Pool.Exec(ctx,
		`UPDATE mfa_bypass_codes
		SET status = 'expired'
		WHERE status = 'active' AND valid_until < NOW()`,
	)
	if err != nil {
		return 0, err
	}
	return int(result.RowsAffected()), nil
}

// HasActiveBypassCode checks if user has an active bypass code
func (s *Service) HasActiveBypassCode(ctx context.Context, userID string) (bool, error) {
	var count int
	err := s.db.Pool.QueryRow(ctx,
		`SELECT COUNT(*) FROM mfa_bypass_codes
		WHERE user_id = $1 AND status = 'active' AND valid_until > NOW()
		AND (max_uses IS NULL OR use_count < max_uses)`,
		userID,
	).Scan(&count)
	return count > 0, err
}

// logBypassAudit records an audit entry
func (s *Service) logBypassAudit(ctx context.Context, bypassID, userID, action string, performedBy *string, ipAddress, userAgent string, details map[string]interface{}) {
	var bypassIDPtr *string
	if bypassID != "" {
		bypassIDPtr = &bypassID
	}
	var userIDPtr *string
	if userID != "" {
		userIDPtr = &userID
	}

	query := `
		INSERT INTO mfa_bypass_audit (id, bypass_code_id, user_id, action, performed_by, ip_address, user_agent, details, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
	`
	s.db.Pool.Exec(ctx, query, uuid.New().String(), bypassIDPtr, userIDPtr, action, performedBy, ipAddress, userAgent, details)
}
