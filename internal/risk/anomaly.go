package risk

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"go.uber.org/zap"
)

// SecurityAlert represents a security alert generated by anomaly detection
type SecurityAlert struct {
	ID                 string                 `json:"id"`
	UserID             *string                `json:"user_id,omitempty"`
	AlertType          string                 `json:"alert_type"`
	Severity           string                 `json:"severity"`
	Status             string                 `json:"status"`
	Title              string                 `json:"title"`
	Description        string                 `json:"description"`
	Details            map[string]interface{} `json:"details,omitempty"`
	SourceIP           string                 `json:"source_ip"`
	RemediationActions []string               `json:"remediation_actions"`
	ResolvedBy         *string                `json:"resolved_by,omitempty"`
	ResolvedAt         *time.Time             `json:"resolved_at,omitempty"`
	CreatedAt          time.Time              `json:"created_at"`
	UpdatedAt          time.Time              `json:"updated_at"`
}

// IPThreatEntry represents an entry in the IP threat list
type IPThreatEntry struct {
	ID           string     `json:"id"`
	IPAddress    string     `json:"ip_address"`
	ThreatType   string     `json:"threat_type"`
	Reason       string     `json:"reason"`
	BlockedUntil *time.Time `json:"blocked_until,omitempty"`
	Permanent    bool       `json:"permanent"`
	CreatedAt    time.Time  `json:"created_at"`
}

// DetectImpossibleTravel checks if the user's login represents physically impossible travel
// based on the distance and time since their last successful login.
func (s *Service) DetectImpossibleTravel(ctx context.Context, userID, ip string, lat, lon float64) *SecurityAlert {
	var lastLat, lastLon float64
	var lastTime time.Time
	var lastIP string

	err := s.db.Pool.QueryRow(ctx,
		`SELECT ip_address, latitude, longitude, created_at FROM login_history
		 WHERE user_id = $1 AND success = true AND latitude != 0 AND longitude != 0
		 ORDER BY created_at DESC LIMIT 1`, userID).Scan(&lastIP, &lastLat, &lastLon, &lastTime)
	if err != nil {
		return nil
	}

	distance := haversineDistance(lastLat, lastLon, lat, lon)
	timeDelta := time.Since(lastTime)
	timeHours := timeDelta.Hours()

	if timeHours <= 0 {
		timeHours = 0.01
	}

	speedKmh := distance / timeHours

	if speedKmh <= 900 {
		return nil
	}

	s.logger.Warn("Impossible travel detected",
		zap.String("user_id", userID),
		zap.String("ip", ip),
		zap.Float64("distance_km", distance),
		zap.Float64("speed_kmh", speedKmh),
	)

	alert := &SecurityAlert{
		ID:        uuid.New().String(),
		UserID:    &userID,
		AlertType: "impossible_travel",
		Severity:  "high",
		Status:    "open",
		Title:     "Impossible Travel Detected",
		Description: fmt.Sprintf(
			"Login from %s detected %.0f km away from previous login in %.1f hours (%.0f km/h), exceeding physical travel limits.",
			ip, distance, timeHours, speedKmh,
		),
		Details: map[string]interface{}{
			"previous_ip":       lastIP,
			"previous_location": fmt.Sprintf("%.4f,%.4f", lastLat, lastLon),
			"distance_km":       distance,
			"time_hours":        timeHours,
			"speed_kmh":         speedKmh,
		},
		SourceIP:           ip,
		RemediationActions: []string{"verify_identity", "require_mfa", "revoke_sessions"},
		CreatedAt:          time.Now(),
		UpdatedAt:          time.Now(),
	}

	if err := s.CreateSecurityAlert(ctx, alert); err != nil {
		s.logger.Error("Failed to create impossible travel alert", zap.Error(err))
	}

	return alert
}

// DetectBruteForce checks for brute force login attempts from a given IP address.
func (s *Service) DetectBruteForce(ctx context.Context, ip, userID string) *SecurityAlert {
	var failedCount int
	err := s.db.Pool.QueryRow(ctx,
		`SELECT COUNT(*) FROM login_history
		 WHERE ip_address = $1 AND success = false AND created_at > NOW() - INTERVAL '15 minutes'`,
		ip).Scan(&failedCount)
	if err != nil {
		s.logger.Error("Failed to query brute force attempts", zap.Error(err))
		return nil
	}

	if failedCount <= 10 {
		return nil
	}

	s.logger.Warn("Brute force attack detected",
		zap.String("ip", ip),
		zap.String("user_id", userID),
		zap.Int("failed_attempts", failedCount),
	)

	var uid *string
	if userID != "" {
		uid = &userID
	}

	alert := &SecurityAlert{
		ID:        uuid.New().String(),
		UserID:    uid,
		AlertType: "brute_force",
		Severity:  "critical",
		Status:    "open",
		Title:     "Brute Force Attack Detected",
		Description: fmt.Sprintf(
			"Detected %d failed login attempts from IP %s in the last 15 minutes.",
			failedCount, ip,
		),
		Details: map[string]interface{}{
			"ip_address":      ip,
			"failed_attempts": failedCount,
			"window_minutes":  15,
		},
		SourceIP:           ip,
		RemediationActions: []string{"block_ip", "lock_account", "notify_admin"},
		CreatedAt:          time.Now(),
		UpdatedAt:          time.Now(),
	}

	if err := s.CreateSecurityAlert(ctx, alert); err != nil {
		s.logger.Error("Failed to create brute force alert", zap.Error(err))
	}

	// Auto-remediate: lock account if user is known
	if userID != "" {
		if err := s.RemediateAccountLock(ctx, userID); err != nil {
			s.logger.Error("Failed to auto-lock account", zap.String("user_id", userID), zap.Error(err))
		}
	}

	// Add IP to threat list with 1-hour block
	blockedUntil := time.Now().Add(1 * time.Hour)
	if err := s.AddToThreatList(ctx, ip, "brute_force", fmt.Sprintf("Automated block: %d failed attempts in 15 minutes", failedCount), false, &blockedUntil); err != nil {
		s.logger.Error("Failed to add IP to threat list", zap.String("ip", ip), zap.Error(err))
	}

	return alert
}

// CheckIPThreatList checks whether an IP address is on the threat list and currently blocked.
func (s *Service) CheckIPThreatList(ctx context.Context, ip string) (bool, string) {
	var reason string
	err := s.db.Pool.QueryRow(ctx,
		`SELECT reason FROM ip_threat_list
		 WHERE ip_address = $1 AND (permanent = true OR blocked_until > NOW())
		 LIMIT 1`, ip).Scan(&reason)
	if err != nil {
		return false, ""
	}
	return true, reason
}

// AddToThreatList adds or updates an IP address entry in the threat list.
func (s *Service) AddToThreatList(ctx context.Context, ip, threatType, reason string, permanent bool, blockedUntil *time.Time) error {
	_, err := s.db.Pool.Exec(ctx,
		`INSERT INTO ip_threat_list (id, ip_address, threat_type, reason, blocked_until, permanent, created_at)
		 VALUES ($1, $2, $3, $4, $5, $6, NOW())
		 ON CONFLICT (ip_address) DO UPDATE
		 SET threat_type = EXCLUDED.threat_type,
		     reason = EXCLUDED.reason,
		     blocked_until = EXCLUDED.blocked_until,
		     permanent = EXCLUDED.permanent`,
		uuid.New().String(), ip, threatType, reason, blockedUntil, permanent)
	if err != nil {
		return fmt.Errorf("failed to add IP to threat list: %w", err)
	}
	return nil
}

// RemoveFromThreatList removes an IP threat entry by its ID.
func (s *Service) RemoveFromThreatList(ctx context.Context, id string) error {
	_, err := s.db.Pool.Exec(ctx,
		`DELETE FROM ip_threat_list WHERE id = $1`, id)
	if err != nil {
		return fmt.Errorf("failed to remove IP from threat list: %w", err)
	}
	return nil
}

// CreateSecurityAlert inserts a new security alert into the database.
func (s *Service) CreateSecurityAlert(ctx context.Context, alert *SecurityAlert) error {
	if alert.ID == "" {
		alert.ID = uuid.New().String()
	}
	if alert.Status == "" {
		alert.Status = "open"
	}
	now := time.Now()
	if alert.CreatedAt.IsZero() {
		alert.CreatedAt = now
	}
	if alert.UpdatedAt.IsZero() {
		alert.UpdatedAt = now
	}

	detailsJSON, err := json.Marshal(alert.Details)
	if err != nil {
		return fmt.Errorf("failed to marshal alert details: %w", err)
	}

	remediationJSON, err := json.Marshal(alert.RemediationActions)
	if err != nil {
		return fmt.Errorf("failed to marshal remediation actions: %w", err)
	}

	_, err = s.db.Pool.Exec(ctx,
		`INSERT INTO security_alerts
		 (id, user_id, alert_type, severity, status, title, description, details, source_ip, remediation_actions, resolved_by, resolved_at, created_at, updated_at)
		 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`,
		alert.ID, alert.UserID, alert.AlertType, alert.Severity, alert.Status,
		alert.Title, alert.Description, detailsJSON, alert.SourceIP, remediationJSON,
		alert.ResolvedBy, alert.ResolvedAt, alert.CreatedAt, alert.UpdatedAt)
	if err != nil {
		return fmt.Errorf("failed to create security alert: %w", err)
	}

	s.logger.Info("Security alert created",
		zap.String("alert_id", alert.ID),
		zap.String("type", alert.AlertType),
		zap.String("severity", alert.Severity),
	)

	return nil
}

// ListSecurityAlerts returns a paginated list of security alerts with optional filters.
func (s *Service) ListSecurityAlerts(ctx context.Context, status, severity, alertType string, limit, offset int) ([]SecurityAlert, int, error) {
	whereClause := ""
	args := []interface{}{}
	argIdx := 1

	conditions := []string{}
	if status != "" {
		conditions = append(conditions, fmt.Sprintf("status = $%d", argIdx))
		args = append(args, status)
		argIdx++
	}
	if severity != "" {
		conditions = append(conditions, fmt.Sprintf("severity = $%d", argIdx))
		args = append(args, severity)
		argIdx++
	}
	if alertType != "" {
		conditions = append(conditions, fmt.Sprintf("alert_type = $%d", argIdx))
		args = append(args, alertType)
		argIdx++
	}

	if len(conditions) > 0 {
		whereClause = " WHERE "
		for i, c := range conditions {
			if i > 0 {
				whereClause += " AND "
			}
			whereClause += c
		}
	}

	var total int
	countQuery := "SELECT COUNT(*) FROM security_alerts" + whereClause
	err := s.db.Pool.QueryRow(ctx, countQuery, args...).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count security alerts: %w", err)
	}

	query := fmt.Sprintf(
		`SELECT id, user_id, alert_type, severity, status, title, description, details, source_ip,
		        remediation_actions, resolved_by, resolved_at, created_at, updated_at
		 FROM security_alerts%s ORDER BY created_at DESC LIMIT $%d OFFSET $%d`,
		whereClause, argIdx, argIdx+1)
	args = append(args, limit, offset)

	rows, err := s.db.Pool.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to query security alerts: %w", err)
	}
	defer rows.Close()

	var alerts []SecurityAlert
	for rows.Next() {
		var a SecurityAlert
		var detailsJSON, remediationJSON []byte

		if err := rows.Scan(
			&a.ID, &a.UserID, &a.AlertType, &a.Severity, &a.Status,
			&a.Title, &a.Description, &detailsJSON, &a.SourceIP,
			&remediationJSON, &a.ResolvedBy, &a.ResolvedAt,
			&a.CreatedAt, &a.UpdatedAt,
		); err != nil {
			s.logger.Error("Failed to scan security alert row", zap.Error(err))
			continue
		}

		if detailsJSON != nil {
			json.Unmarshal(detailsJSON, &a.Details)
		}
		if remediationJSON != nil {
			json.Unmarshal(remediationJSON, &a.RemediationActions)
		}

		alerts = append(alerts, a)
	}

	return alerts, total, nil
}

// GetSecurityAlert retrieves a single security alert by ID.
func (s *Service) GetSecurityAlert(ctx context.Context, id string) (*SecurityAlert, error) {
	var a SecurityAlert
	var detailsJSON, remediationJSON []byte

	err := s.db.Pool.QueryRow(ctx,
		`SELECT id, user_id, alert_type, severity, status, title, description, details, source_ip,
		        remediation_actions, resolved_by, resolved_at, created_at, updated_at
		 FROM security_alerts WHERE id = $1`, id).Scan(
		&a.ID, &a.UserID, &a.AlertType, &a.Severity, &a.Status,
		&a.Title, &a.Description, &detailsJSON, &a.SourceIP,
		&remediationJSON, &a.ResolvedBy, &a.ResolvedAt,
		&a.CreatedAt, &a.UpdatedAt,
	)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("security alert not found")
		}
		return nil, fmt.Errorf("failed to get security alert: %w", err)
	}

	if detailsJSON != nil {
		json.Unmarshal(detailsJSON, &a.Details)
	}
	if remediationJSON != nil {
		json.Unmarshal(remediationJSON, &a.RemediationActions)
	}

	return &a, nil
}

// UpdateAlertStatus updates the status of a security alert.
func (s *Service) UpdateAlertStatus(ctx context.Context, id, status, resolvedBy string) error {
	if status == "resolved" || status == "false_positive" {
		_, err := s.db.Pool.Exec(ctx,
			`UPDATE security_alerts SET status = $1, resolved_by = $2, resolved_at = NOW(), updated_at = NOW()
			 WHERE id = $3`,
			status, resolvedBy, id)
		if err != nil {
			return fmt.Errorf("failed to update alert status: %w", err)
		}
	} else {
		_, err := s.db.Pool.Exec(ctx,
			`UPDATE security_alerts SET status = $1, updated_at = NOW() WHERE id = $2`,
			status, id)
		if err != nil {
			return fmt.Errorf("failed to update alert status: %w", err)
		}
	}

	s.logger.Info("Security alert status updated",
		zap.String("alert_id", id),
		zap.String("status", status),
	)

	return nil
}

// ListIPThreats returns a paginated list of IP threat entries.
func (s *Service) ListIPThreats(ctx context.Context, limit, offset int) ([]IPThreatEntry, int, error) {
	var total int
	err := s.db.Pool.QueryRow(ctx, `SELECT COUNT(*) FROM ip_threat_list`).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count IP threats: %w", err)
	}

	rows, err := s.db.Pool.Query(ctx,
		`SELECT id, ip_address, threat_type, reason, blocked_until, permanent, created_at
		 FROM ip_threat_list ORDER BY created_at DESC LIMIT $1 OFFSET $2`,
		limit, offset)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to query IP threats: %w", err)
	}
	defer rows.Close()

	var entries []IPThreatEntry
	for rows.Next() {
		var e IPThreatEntry
		if err := rows.Scan(&e.ID, &e.IPAddress, &e.ThreatType, &e.Reason,
			&e.BlockedUntil, &e.Permanent, &e.CreatedAt); err != nil {
			s.logger.Error("Failed to scan IP threat row", zap.Error(err))
			continue
		}
		entries = append(entries, e)
	}

	return entries, total, nil
}

// RunAnomalyCheck orchestrates all anomaly detection checks for a login attempt.
func (s *Service) RunAnomalyCheck(ctx context.Context, userID, ip, userAgent string, lat, lon float64) []SecurityAlert {
	var alerts []SecurityAlert

	blocked, reason := s.CheckIPThreatList(ctx, ip)
	if blocked {
		alert := &SecurityAlert{
			ID:        uuid.New().String(),
			AlertType: "blocked_ip",
			Severity:  "critical",
			Status:    "open",
			Title:     "Login Attempt from Blocked IP",
			Description: fmt.Sprintf(
				"Login attempt from blocked IP address %s. Reason: %s", ip, reason,
			),
			Details: map[string]interface{}{
				"ip_address":   ip,
				"block_reason": reason,
				"user_agent":   userAgent,
			},
			SourceIP:           ip,
			RemediationActions: []string{"block_request", "notify_admin"},
			CreatedAt:          time.Now(),
			UpdatedAt:          time.Now(),
		}
		if userID != "" {
			alert.UserID = &userID
		}

		if err := s.CreateSecurityAlert(ctx, alert); err != nil {
			s.logger.Error("Failed to create blocked IP alert", zap.Error(err))
		}
		alerts = append(alerts, *alert)
	}

	if lat != 0 && lon != 0 && userID != "" {
		if alert := s.DetectImpossibleTravel(ctx, userID, ip, lat, lon); alert != nil {
			alerts = append(alerts, *alert)
		}
	}

	if alert := s.DetectBruteForce(ctx, ip, userID); alert != nil {
		alerts = append(alerts, *alert)
	}

	return alerts
}

// RemediateAccountLock locks a user account by setting enabled to false.
func (s *Service) RemediateAccountLock(ctx context.Context, userID string) error {
	_, err := s.db.Pool.Exec(ctx,
		`UPDATE users SET enabled = false WHERE id = $1`, userID)
	if err != nil {
		return fmt.Errorf("failed to lock account: %w", err)
	}

	s.logger.Info("Account locked via auto-remediation", zap.String("user_id", userID))
	return nil
}

// RemediateRevokeSessions revokes all active sessions for a user.
func (s *Service) RemediateRevokeSessions(ctx context.Context, userID string) error {
	_, err := s.db.Pool.Exec(ctx,
		`UPDATE sessions SET revoked = true, revoked_at = NOW() WHERE user_id = $1 AND (revoked IS NULL OR revoked = false)`, userID)
	if err != nil {
		return fmt.Errorf("failed to revoke sessions: %w", err)
	}

	s.logger.Info("Sessions revoked via auto-remediation", zap.String("user_id", userID))
	return nil
}

// RemediateRequireReauth forces re-authentication by expiring all active sessions for a user.
func (s *Service) RemediateRequireReauth(ctx context.Context, userID string) error {
	_, err := s.db.Pool.Exec(ctx,
		`UPDATE sessions SET expires_at = NOW() WHERE user_id = $1`, userID)
	if err != nil {
		return fmt.Errorf("failed to expire sessions: %w", err)
	}

	s.logger.Info("Re-authentication required via auto-remediation", zap.String("user_id", userID))
	return nil
}
