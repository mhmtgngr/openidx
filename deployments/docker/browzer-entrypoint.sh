#!/bin/sh
# BrowZer bootstrapper entrypoint wrapper.
# Watches /shared-config/config.json for changes and gracefully restarts
# the node process when the targets configuration is updated.
# This allows dynamic BrowZer target management without container restarts.
#
# The config.json is generated by the access-service and contains:
# { "ZITI_BROWZER_BOOTSTRAPPER_TARGETS": "{\"targetArray\":[...]}" }
#
# Since nconf gives env vars higher priority than config files, we read
# the targets from config.json and export them as env vars before starting node.

set -e

CONFIG_FILE="/shared-config/config.json"
POLL_INTERVAL=5
NODE_PID=""

# Forward SIGTERM to the node process for clean shutdown
cleanup() {
    echo "[entrypoint] Received shutdown signal"
    if [ -n "$NODE_PID" ] && kill -0 "$NODE_PID" 2>/dev/null; then
        kill -TERM "$NODE_PID"
        wait "$NODE_PID" 2>/dev/null
    fi
    exit 0
}
trap cleanup TERM INT

# Load targets from config file into env var (overrides docker-compose default)
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Extract the ZITI_BROWZER_BOOTSTRAPPER_TARGETS value from config.json
        # The file format is: {"ZITI_BROWZER_BOOTSTRAPPER_TARGETS": "<json-string>"}
        TARGETS=$(node -e "
            try {
                const cfg = require('$CONFIG_FILE');
                if (cfg.ZITI_BROWZER_BOOTSTRAPPER_TARGETS) {
                    process.stdout.write(cfg.ZITI_BROWZER_BOOTSTRAPPER_TARGETS);
                }
            } catch(e) {}
        " 2>/dev/null)
        if [ -n "$TARGETS" ]; then
            export ZITI_BROWZER_BOOTSTRAPPER_TARGETS="$TARGETS"
            echo "[entrypoint] Loaded targets from config file"
            return 0
        fi
    fi
    echo "[entrypoint] Using default targets from env var"
    return 1
}

start_node() {
    load_config
    echo "[entrypoint] Starting bootstrapper..."
    node /home/node/app/index.js &
    NODE_PID=$!
    echo "[entrypoint] Bootstrapper started with PID $NODE_PID"
}

restart_node() {
    echo "[entrypoint] Restarting bootstrapper due to config change..."
    if [ -n "$NODE_PID" ] && kill -0 "$NODE_PID" 2>/dev/null; then
        kill -TERM "$NODE_PID"
        # Wait up to 10 seconds for graceful shutdown
        WAIT_COUNT=0
        while kill -0 "$NODE_PID" 2>/dev/null && [ $WAIT_COUNT -lt 10 ]; do
            sleep 1
            WAIT_COUNT=$((WAIT_COUNT + 1))
        done
        # Force kill if still running
        if kill -0 "$NODE_PID" 2>/dev/null; then
            echo "[entrypoint] Force killing bootstrapper..."
            kill -9 "$NODE_PID" 2>/dev/null
        fi
        wait "$NODE_PID" 2>/dev/null || true
    fi
    start_node
}

# Wait briefly for config file (access-service may not have written it yet)
echo "[entrypoint] Checking for config file at $CONFIG_FILE..."
WAIT_ATTEMPTS=0
while [ ! -f "$CONFIG_FILE" ] && [ $WAIT_ATTEMPTS -lt 30 ]; do
    sleep 2
    WAIT_ATTEMPTS=$((WAIT_ATTEMPTS + 1))
done

if [ -f "$CONFIG_FILE" ]; then
    echo "[entrypoint] Config file found"
else
    echo "[entrypoint] Config file not found after 60s, using env var fallback"
fi

# Start the bootstrapper
start_node

# Get initial mtime (0 if file doesn't exist)
LAST_MTIME=$(stat -c %Y "$CONFIG_FILE" 2>/dev/null || echo "0")

# Poll for config changes
while true; do
    sleep $POLL_INTERVAL

    # Check if node process crashed
    if ! kill -0 "$NODE_PID" 2>/dev/null; then
        echo "[entrypoint] Node process died unexpectedly, restarting..."
        start_node
        continue
    fi

    # Check for config file changes
    CURR_MTIME=$(stat -c %Y "$CONFIG_FILE" 2>/dev/null || echo "0")
    if [ "$CURR_MTIME" != "$LAST_MTIME" ] && [ "$CURR_MTIME" != "0" ]; then
        echo "[entrypoint] Config file changed (mtime: $LAST_MTIME -> $CURR_MTIME)"
        LAST_MTIME="$CURR_MTIME"
        # Small delay to ensure file write is complete
        sleep 1
        restart_node
    fi
done
