AUTH CODE: 
--- internal/governance/certification.go ---
// Package governance provides access certification campaign functionality
package governance

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"

	"github.com/openidx/openidx/internal/common/database"
)

// CampaignStatus represents the state of a certification campaign
type CampaignStatus string

const (
	CampaignStatusDraft      CampaignStatus = "draft"
	CampaignStatusActive     CampaignStatus = "active"
	CampaignStatusCompleted  CampaignStatus = "completed"
	CampaignStatusExpired    CampaignStatus = "expired"
	CampaignStatusCancelled  CampaignStatus = "cancelled"
)

// CertificationDecision represents the decision on a certification review item
type CertificationDecision string

const (
	DecisionConfirm    CertificationDecision = "confirm"
	DecisionRevoke     CertificationDecision = "revoke"
	DecisionModify     CertificationDecision = "modify"
	DecisionPending    CertificationDecision = "pending"
)

// CampaignScope defines what resources are included in the campaign
type CampaignScope struct {
	ResourceTypes []string `json:"resource_types"` // e.g., ["role", "group", "application"]
	ResourceIDs   []string `json:"resource_ids"`   // Specific resources, or empty for all
	UserIDs       []string `json:"user_ids"`       // Specific users to review, or empty for all with access
	OUPaths       []string `json:"ou_paths"`       // Organizational unit paths
	Tags          []string `json:"tags"`           // Tag-based filtering
}

// CampaignReviewer defines who should perform reviews
type CampaignReviewer struct {
	Type string `json:"type"` // "user", "role", "manager", "resource_owner"
	ID   string `json:"id"`   // User ID, role ID, or empty for manager-based
}

// CertificationCampaign represents an access certification campaign
type CertificationCampaign struct {
	ID              string          `json:"id"`
	Name            string          `json:"name"`
	Description     string          `json:"description"`
	Status          CampaignStatus  `json:"status"`
	Scope           CampaignScope   `json:"scope"`
	Reviewers       []CampaignReviewer `json:"reviewers"`
	Deadline        time.Time       `json:"deadline"`
--- internal/governance/workflows.go ---
package governance

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"go.uber.org/zap"
)

// AccessRequest represents a request for access to a role, group, or application
type AccessRequest struct {
	ID             string      `json:"id"`
	RequesterID    string      `json:"requester_id"`
	RequesterName  string      `json:"requester_name,omitempty"`
	ResourceType   string      `json:"resource_type"`
	ResourceID     string      `json:"resource_id"`
	ResourceName   string      `json:"resource_name"`
	Justification  string      `json:"justification"`
	Status         string      `json:"status"`
	Priority       string      `json:"priority"`
	ExpiresAt      *time.Time  `json:"expires_at,omitempty"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	Approvals      []Approval  `json:"approvals,omitempty"`
}

// Approval represents a single approval/denial decision on an access request
type Approval struct {
	ID           string     `json:"id"`
	RequestID    string     `json:"request_id"`
	ApproverID   string     `json:"approver_id"`
	ApproverName string     `json:"approver_name,omitempty"`
	StepOrder    int        `json:"step_order"`
	Decision     string     `json:"decision"`
	Comments     string     `json:"comments"`
	DecidedAt    *time.Time `json:"decided_at,omitempty"`
	CreatedAt    time.Time  `json:"created_at"`
}

// ApprovalPolicy defines who must approve requests for specific resource types
type ApprovalPolicy struct {
	ID                    string                   `json:"id"`
	Name                  string                   `json:"name"`
	ResourceType          string                   `json:"resource_type"`
	ResourceID            *string                  `json:"resource_id,omitempty"`
	ApprovalSteps         []map[string]interface{} `json:"approval_steps"`
	AutoApproveConditions map[string]interface{}   `json:"auto_approve_conditions,omitempty"`
	MaxWaitHours          int                      `json:"max_wait_hours"`
	Enabled               bool                     `json:"enabled"`
	CreatedAt             time.Time                `json:"created_at"`
	UpdatedAt             time.Time                `json:"updated_at"`
}

// parseDuration converts a human-friendly duration string to time.Duration.
--- internal/governance/zt_policy_handler_test.go ---
// Package governance provides tests for Zero Trust policy HTTP handlers
package governance

import (
	"bytes"
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
	"go.uber.org/zap/zaptest"

	"github.com/openidx/openidx/internal/common/database"
)

// setupHandlerTest creates test database and handler
func setupHandlerTest(t *testing.T) (*database.PostgresDB, *ZTPolicyHandler, func()) {
	t.Helper()

	ctx := context.Background()

	// Start PostgreSQL container
	req := testcontainers.ContainerRequest{
		Image:        "postgres:16-alpine",
		ExposedPorts: []string{"5432/tcp"},
		Env: map[string]string{
			"POSTGRES_USER":     "test",
			"POSTGRES_PASSWORD": "test",
			"POSTGRES_DB":       "testdb",
		},
		WaitingFor: wait.ForLog("database system is ready to accept connections").
			WithOccurrence(2).
			WithStartupTimeout(30 * time.Second),
	}

	container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	if err != nil {
		t.Skipf("Failed to start test container: %v", err)
		return nil, nil, func() {}
	}

	host, err := container.Host(ctx)
	if err != nil {
		container.Terminate(ctx)
		t.Skipf("Failed to get container host: %v", err)
		return nil, nil, func() {}
	}

	port, err := container.MappedPort(ctx, "5432")
	if err != nil {
		container.Terminate(ctx)
		t.Skipf("Failed to get container port: %v", err)
--- internal/governance/zt_policy_handler.go ---
// Package governance provides HTTP handlers for Zero Trust policy management
package governance

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

// rateLimitEntry tracks rate limit state per client
type rateLimitEntry struct {
	count     int64
	resetTime time.Time
}

// rateLimitStore tracks in-memory rate limits
var rateLimitStore = struct {
	sync.RWMutex
	entries map[string]*rateLimitEntry
}{
	entries: make(map[string]*rateLimitEntry),
}

// ZTPolicyHandler handles HTTP requests for policy management
type ZTPolicyHandler struct {
	store     *ZTPolicyStore
	eval      *ZTPolicyEvaluator
	logger    *zap.Logger
}

// NewZTPolicyHandler creates a new policy handler
func NewZTPolicyHandler(store *ZTPolicyStore, logger *zap.Logger) *ZTPolicyHandler {
	if logger == nil {
		logger = zap.NewNop()
	}
	return &ZTPolicyHandler{
		store:  store,
		eval:   NewZTPolicyEvaluator(),
		logger: logger.With(zap.String("handler", "zt_policy")),
	}
}

// RegisterRoutes registers all policy routes
func (h *ZTPolicyHandler) RegisterRoutes(r gin.IRouter) {
	policies := r.Group("/api/v1/policies")
	{
		policies.POST("", h.CreatePolicy)
		policies.GET("", h.ListPolicies)
		policies.GET("/count", h.CountPolicies)
		policies.GET("/:id", h.GetPolicy)
		policies.PUT("/:id", h.UpdatePolicy)
		policies.DELETE("/:id", h.DeletePolicy)
		policies.PATCH("/:id/enable", h.SetPolicyEnabled)
--- internal/governance/zt_policy_test.go ---
// Package governance provides tests for Zero Trust policy evaluation
package governance

import (
	"encoding/json"
	"strconv"
	"testing"
	"time"

	"go.uber.org/zap/zaptest"
)

// TestZTPolicyEvaluator_AllowPolicy tests simple allow policy
func TestZTPolicyEvaluator_AllowPolicy(t *testing.T) {
	_ = zaptest.NewLogger(t) // Logger available for debugging
	eval := NewZTPolicyEvaluator()

	policy := NewZTPolicy(
		"Admin Full Access",
		"Allow admins full access",
		EffectAllow,
		ConditionGroup{
			Operator: OpAnd,
			Conditions: []Condition{
				{
					Field:    "subject.authenticated",
					Operator: OpEquals,
					Value:    true,
				},
				{
					Field:    "subject.roles",
					Operator: OpHasRole,
					Value:    "admin",
				},
			},
		},
		100,
	)
	eval.AddPolicy(policy)

	input := ZTPolicyInput{
		Subject: Subject{
			ID:            "user1",
			Type:          "user",
			Authenticated: true,
			Roles:         []string{"admin"},
			Groups:        []string{},
		},
		Resource: Resource{
			ID:   "res1",
			Type: "document",
		},
		Action: "read",
		Context: EvaluationContext{
			Time: time.Now(),
		},
	}

	result := eval.Evaluate(input)
	if !result.Allowed {
--- internal/governance/policy_example_test.go ---
// Package governance provides policy evaluation examples
package governance

import (
	"context"
	"fmt"
	"log"
	"time"

	"go.uber.org/zap"
)

// examplePolicyEvaluator demonstrates basic usage of the PolicyEvaluator
func examplePolicyEvaluator() {
	// Create a new policy evaluator
	config := PolicyEvaluatorConfig{
		OPAURL:               "http://localhost:8181",
		DefaultPolicyTimeout: 5 * time.Second,
		EnableMetrics:        true,
		Logger:               zap.NewExample(),
	}

	evaluator := NewPolicyEvaluator(config)

	// Load a policy from bytes
	regoPolicy := `
package example

default allow = false

allow {
    input.user.roles[_] == "admin"
}

allow {
    input.action == "read"
    input.resource.type == "public"
}

deny[msg] {
    not allow
    msg := "Access denied: insufficient permissions"
}
`

	if err := evaluator.LoadPolicyFromBytes("example", []byte(regoPolicy)); err != nil {
		log.Fatalf("Failed to load policy: %v", err)
	}

	// Evaluate a policy decision
	ctx := context.Background()
	input := PolicyInput{
		User: PolicyUser{
			ID:            "user123",
			Username:      "johndoe",
			Roles:         []string{"user"},
			Authenticated: true,
		},
		Resource: PolicyResource{
			Type: "document",
--- internal/governance/service.go ---
// Package governance provides access governance and compliance functionality
package governance

import (
	"context"
	"crypto/rsa"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math/big"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/golang-jwt/jwt/v5"
	"go.uber.org/zap"

	"github.com/openidx/openidx/internal/common/config"
	"github.com/openidx/openidx/internal/common/database"
)

// AccessReview represents an access certification review
type AccessReview struct {
	ID           string            `json:"id"`
	Name         string            `json:"name"`
	Description  string            `json:"description"`
	Type         ReviewType        `json:"type"`
	Status       ReviewStatus      `json:"status"`
	ReviewerID   string            `json:"reviewer_id"`
	Scope        ReviewScope       `json:"scope"`
	StartDate    time.Time         `json:"start_date"`
	EndDate      time.Time         `json:"end_date"`
	CreatedAt    time.Time         `json:"created_at"`
	CompletedAt  *time.Time        `json:"completed_at,omitempty"`
	TotalItems   int               `json:"total_items"`
	ReviewedItems int              `json:"reviewed_items"`
}

// ReviewType defines the type of access review
type ReviewType string

const (
	ReviewTypeUserAccess      ReviewType = "user_access"
	ReviewTypeRoleAssignment  ReviewType = "role_assignment"
	ReviewTypeApplicationAccess ReviewType = "application_access"
	ReviewTypePrivilegedAccess ReviewType = "privileged_access"
)

// ReviewStatus defines the status of an access review
type ReviewStatus string

const (
	ReviewStatusPending    ReviewStatus = "pending"
	ReviewStatusInProgress ReviewStatus = "in_progress"
	ReviewStatusCompleted  ReviewStatus = "completed"
--- internal/governance/policy.go ---
// Package governance provides policy evaluation and access governance functionality
package governance

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"

	"github.com/open-policy-agent/opa/ast"
	"github.com/open-policy-agent/opa/rego"
	"github.com/open-policy-agent/opa/storage"
	"github.com/open-policy-agent/opa/storage/inmem"
	"go.uber.org/zap"

	"github.com/openidx/openidx/internal/common/opa"
)

// compiledPolicy represents a compiled Rego policy ready for evaluation
type compiledPolicy struct {
	name      string
	module    *ast.Module
	compiler  *ast.Compiler
	policyRego string
	createdAt time.Time
}

// PolicyInput represents the input data for policy evaluation
type PolicyInput struct {
	User     PolicyUser     `json:"user"`
	Resource PolicyResource `json:"resource"`
	Action   string         `json:"action"`
	Context  PolicyContext  `json:"context,omitempty"`
}

// PolicyUser represents the user context in policy evaluation
type PolicyUser struct {
	ID            string            `json:"id"`
	Username      string            `json:"username"`
	Email         string            `json:"email,omitempty"`
	Roles         []string          `json:"roles"`
	Groups        []string          `json:"groups,omitempty"`
	TenantID      string            `json:"tenant_id,omitempty"`
	Attributes    map[string]string `json:"attributes,omitempty"`
	Authenticated bool              `json:"authenticated"`
}

// PolicyResource represents the resource being accessed
type PolicyResource struct {
	Type       string            `json:"type"`
	ID         string            `json:"id,omitempty"`
	Name       string            `json:"name,omitempty"`
	Owner      string            `json:"owner,omitempty"`
	Path       string            `json:"path,omitempty"`
	Attributes map[string]string `json:"attributes,omitempty"`
	Tags       []string          `json:"tags,omitempty"`
}
--- internal/governance/zt_policy.go ---
// Package governance provides Zero Trust policy evaluation for OpenIDX
package governance

import (
	"encoding/json"
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/google/uuid"
)

// ZTPolicy represents a Zero Trust access policy with versioning support
type ZTPolicy struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Effect      PolicyEffect    `json:"effect"`
	Conditions  ConditionGroup  `json:"conditions"`
	Priority    int             `json:"priority"`
	Enabled     bool            `json:"enabled"`
	TenantID    string          `json:"tenant_id,omitempty"`
	Version     int             `json:"version"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	CreatedBy   string          `json:"created_by,omitempty"`
	UpdatedBy   string          `json:"updated_by,omitempty"`
	Metadata    json.RawMessage `json:"metadata,omitempty"`
}

// PolicyEffect defines the allow/deny effect of a policy
type PolicyEffect string

const (
	EffectAllow PolicyEffect = "allow"
	EffectDeny  PolicyEffect = "deny"
)

// ConditionGroup represents a group of conditions with logical operators
type ConditionGroup struct {
	Operator LogicalOperator `json:"operator"` // and, or, not
	Conditions []Condition    `json:"conditions,omitempty"`
	Groups     []ConditionGroup `json:"groups,omitempty"` // Nested groups
}

// LogicalOperator defines how conditions/groups are combined
type LogicalOperator string

const (
	OpAnd LogicalOperator = "and"
	OpOr  LogicalOperator = "or"
	OpNot LogicalOperator = "not"
)

// Condition represents a single condition to evaluate
type Condition struct {
	Field    string      `json:"field"`     // user.role, resource.type, context.ip, etc.
	Operator string      `json:"operator"`  // equals, contains, in, regex, etc.
	Value    interface{} `json:"value"`     // The value to compare against
--- internal/governance/zt_policy_store_test.go ---
// Package governance provides tests for Zero Trust policy storage
package governance

import (
	"context"
	"testing"
	"time"

	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
	"go.uber.org/zap/zaptest"

	"github.com/openidx/openidx/internal/common/database"
)

// setupTestDB creates a test database container
func setupTestDB(t *testing.T) (*database.PostgresDB, func()) {
	t.Helper()

	ctx := context.Background()

	// Start PostgreSQL container
	req := testcontainers.ContainerRequest{
		Image:        "postgres:16-alpine",
		ExposedPorts: []string{"5432/tcp"},
		Env: map[string]string{
			"POSTGRES_USER":     "test",
			"POSTGRES_PASSWORD": "test",
			"POSTGRES_DB":       "testdb",
		},
		WaitingFor: wait.ForLog("database system is ready to accept connections").
			WithOccurrence(2).
			WithStartupTimeout(30 * time.Second),
	}

	container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	if err != nil {
		t.Skipf("Failed to start test container: %v", err)
		return nil, func() {}
	}

	host, err := container.Host(ctx)
	if err != nil {
		container.Terminate(ctx)
		t.Skipf("Failed to get container host: %v", err)
		return nil, func() {}
	}

	port, err := container.MappedPort(ctx, "5432")
	if err != nil {
		container.Terminate(ctx)
		t.Skipf("Failed to get container port: %v", err)
		return nil, func() {}
	}

	connString := "postgres://test:test@" + host + ":" + port.Port() + "/testdb?sslmode=disable"
HANDLERS: 
--- internal/oauth/handlers_passwordless.go ---
// Package oauth - Passwordless authentication OAuth handlers
// Implements passkey, magic link, QR login, and MFA OTP delivery flows.
package oauth

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/url"
	"regexp"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/go-webauthn/webauthn/protocol"
	"github.com/go-webauthn/webauthn/webauthn"
	"go.uber.org/zap"
)

// validSessionIDPattern validates session tokens to prevent Redis key injection
// Only allows hexadecimal characters (0-9, a-f) and hyphens for UUIDs
var validSessionIDPattern = regexp.MustCompile(`^[a-zA-Z0-9\-_\.]{8,128}$`)

// maxSessionLength prevents excessively long session strings
const maxSessionLength = 128

// isValidSessionID validates session token format to prevent Redis key injection attacks
func isValidSessionID(sessionID string) bool {
	if len(sessionID) == 0 || len(sessionID) > maxSessionLength {
		return false
	}
	// Check for valid characters only (alphanumeric, hyphen, underscore, dot)
	// This prevents Redis injection via special characters like newlines, spaces, etc.
	return validSessionIDPattern.MatchString(sessionID)
}

// handleMFASendOTP triggers SMS or Email OTP delivery during the login MFA flow.
// POST /oauth/mfa-send-otp
func (s *Service) handleMFASendOTP(c *gin.Context) {
	var req struct {
		MFASession string `json:"mfa_session"`
		Method     string `json:"method"` // "sms" or "email"
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": "invalid_request", "error_description": "invalid request body"})
		return
	}
--- internal/auth/middleware_test.go ---
// Package auth provides unit tests for RBAC middleware
package auth

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"go.uber.org/zap/zaptest"
)

// MockTokenValidator is a mock implementation of TokenValidator for testing
type MockTokenValidator struct {
	ValidToken   bool
	ExpiredToken bool
	UserID       string
	TenantID     string
	Roles        []string
	ShouldFail   bool
}

func (m *MockTokenValidator) ValidateAccessToken(ctx context.Context, tokenString string) (*Claims, error) {
	if m.ShouldFail {
		return nil, ErrTokenInvalid
	}
	if m.ExpiredToken {
		return nil, ErrTokenExpired
	}
	if !m.ValidToken {
		return nil, ErrTokenInvalid
	}

	return &Claims{
		Subject:   m.UserID,
		TenantID:  m.TenantID,
		Roles:     m.Roles,
		TokenType: "access",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(1 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}, nil
}

func TestAuthenticate_Success(t *testing.T) {
	gin.SetMode(gin.TestMode)
--- internal/auth/middleware.go ---
// Package auth provides RBAC middleware for OpenIDX Gin services
package auth

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

var (
	// ErrMissingAuthHeader is returned when Authorization header is missing
	ErrMissingAuthHeader = errors.New("missing authorization header")

	// ErrInvalidAuthHeader is returned when Authorization header format is invalid
	ErrInvalidAuthHeader = errors.New("invalid authorization header format")

	// ErrInvalidToken is returned when token validation fails
	ErrInvalidToken = errors.New("invalid token")

	// ErrMissingRoles is returned when no roles are found in context
	ErrMissingRoles = errors.New("no roles found in context")

	// ErrInsufficientRole is returned when user doesn't have required role
	ErrInsufficientRole = errors.New("insufficient role privileges")

	// ErrInsufficientPermission is returned when user lacks required permission
	ErrInsufficientPermission = errors.New("insufficient permissions")
)

// TokenValidator defines the interface for validating JWT tokens
type TokenValidator interface {
	ValidateAccessToken(ctx context.Context, tokenString string) (*Claims, error)
}

// TokenServiceValidator adapts TokenService to TokenValidator interface
type TokenServiceValidator struct {
	tokenService *TokenService
}

// NewTokenServiceValidator creates a new TokenServiceValidator
func NewTokenServiceValidator(ts *TokenService) *TokenServiceValidator {
	return &TokenServiceValidator{tokenService: ts}
}

// ValidateAccessToken implements TokenValidator
--- internal/audit/handler.go ---
// Package audit provides HTTP handlers for tamper-evident audit logging
package audit

import (
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

// Handler provides HTTP handlers for audit operations
type Handler struct {
	store    *Store
	searcher *Searcher
	logger   *zap.Logger
}

// NewHandler creates a new audit handler
func NewHandler(store *Store, searcher *Searcher, logger *zap.Logger) *Handler {
	return &Handler{
		store:    store,
		searcher: searcher,
		logger:   logger.With(zap.String("component", "audit-handler")),
	}
}

// RegisterRoutes registers audit routes with the Gin router
func (h *Handler) RegisterRoutes(r *gin.RouterGroup) {
	// All audit routes require audit:read permission
	audit := r.Group("")
	audit.Use(RequirePermission("audit", "read"))
	{
		// Search audit events
		audit.GET("/events", h.SearchEvents)

		// Get a specific event by ID
		audit.GET("/events/:id", h.GetEvent)

		// Verify integrity of the audit chain
		audit.GET("/integrity", h.VerifyIntegrity)

		// Get statistics
		audit.GET("/statistics", h.GetStatistics)

		// Get timeline for an entity
		audit.GET("/timeline", h.GetTimeline)
	}
--- internal/identity/handlers_otp.go ---
// Package identity - HTTP handlers for SMS and Email OTP MFA
package identity

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// --- SMS OTP Handlers ---

// handleEnrollSMS starts SMS MFA enrollment
func (s *Service) handleEnrollSMS(c *gin.Context) {
	userID := c.GetString("user_id")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
		return
	}

	var req struct {
		PhoneNumber string `json:"phone_number" binding:"required"`
		CountryCode string `json:"country_code"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "phone_number is required"})
		return
	}

	// Default country code to +1 (US) if not provided
	if req.CountryCode == "" {
		req.CountryCode = "+1"
	}

	enrollment, code, err := s.EnrollSMS(c.Request.Context(), userID, req.PhoneNumber, req.CountryCode)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	response := gin.H{
		"id":           enrollment.ID,
		"phone_number": maskPhone(enrollment.PhoneNumber),
		"country_code": enrollment.CountryCode,
		"verified":     enrollment.Verified,
		"message":      "Verification code sent to your phone",
	}

	// CRITICAL: NEVER expose OTP codes in production
	// OTP codes must NEVER be included in API responses in production environments
--- internal/identity/handler.go ---
// Package identity provides HTTP handlers for identity CRUD operations
package identity

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"

	apperrors "github.com/openidx/openidx/internal/common/errors"
)

// CreateOrUpdateUserRequest represents the request body for creating/updating a user
type CreateOrUpdateUserRequest struct {
	UserName    string   `json:"userName" binding:"required"`
	Email       string   `json:"email" binding:"required,email"`
	FirstName   string   `json:"firstName"`
	LastName    string   `json:"lastName"`
	DisplayName *string  `json:"displayName"`
	Enabled     *bool    `json:"enabled"`
	Roles       []string `json:"roles"`
	Groups      []string `json:"groups"`
}

// ToUser converts the request to a User model
func (r *CreateOrUpdateUserRequest) ToUser() *User {
	user := NewUser(r.UserName)
	user.SetEmail(r.Email)
	user.SetFirstName(r.FirstName)
	user.SetLastName(r.LastName)

	if r.DisplayName != nil {
		user.DisplayName = r.DisplayName
	}
	if r.Enabled != nil {
		user.Enabled = *r.Enabled
		user.Active = *r.Enabled
	}
	if len(r.Roles) > 0 {
		user.Roles = r.Roles
	}
	if len(r.Groups) > 0 {
		user.Groups = r.Groups
	}

	return user
}

// CreateOrUpdateGroupRequest represents the request body for creating/updating a group
--- internal/identity/handlers_federation.go ---
package identity

import (
	"encoding/json"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

// validDomainPattern validates email domains to prevent SQL injection
// Only allows alphanumeric, hyphens, and dots in domain names
var validDomainPattern = regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$`)

// maxDomainLength prevents excessively long domain strings
const maxDomainLength = 253

// isValidDomain performs strict validation of email domain format
// to prevent SQL injection and ensure RFC-compliant domain names
func isValidDomain(domain string) bool {
	// Check length limit (RFC 1035)
	if len(domain) == 0 || len(domain) > maxDomainLength {
		return false
	}
	// Must contain at least one dot for proper domain structure
	if !strings.Contains(domain, ".") {
		return false
	}
	// Check against strict pattern (no SQL injection characters)
	return validDomainPattern.MatchString(domain)
}

// handleFederationDiscover is a PUBLIC endpoint that returns the IdP to redirect to based on email domain.
func (s *Service) handleFederationDiscover(c *gin.Context) {
	var req struct {
		Email string `json:"email" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Email is required"})
		return
	}

	parts := strings.SplitN(req.Email, "@", 2)
	if len(parts) != 2 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid email format"})
		return
	}
--- internal/identity/handlers_mfa.go ---
// Package identity - MFA HTTP handlers
package identity

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/go-webauthn/webauthn/protocol"
)

// WebAuthn Handlers

func (s *Service) handleBeginWebAuthnRegistration(c *gin.Context) {
	// CRITICAL: Only get user ID from authenticated context
	// NEVER allow user_id from query/header/request body to prevent IDOR attacks
	userID := c.GetString("user_id")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
		return
	}

	options, err := s.BeginWebAuthnRegistration(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, options)
}

func (s *Service) handleFinishWebAuthnRegistration(c *gin.Context) {
	// CRITICAL: Only get user ID from authenticated context
	// NEVER allow user_id from query/header/request body to prevent IDOR attacks
	userID := c.GetString("user_id")
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
		return
	}

	// Parse credential name from query or header (these are metadata, not identifiers)
	credentialName := c.Query("name")
	if credentialName == "" {
		credentialName = c.GetHeader("X-Credential-Name")
	}

	// Parse WebAuthn response
	parsedResponse, err := protocol.ParseCredentialCreationResponseBody(c.Request.Body)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid WebAuthn response: " + err.Error()})
		return
Check: SQL injection, XSS, CSRF, insecure JWT, weak crypto, missing auth, IDOR, data exposure. Be thorough.
