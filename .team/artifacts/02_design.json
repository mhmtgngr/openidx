{
  "architecture_decisions": [
    {
      "decision": "Use existing docker-compose infrastructure with production environment overrides",
      "rationale": "OpenIDX already has a complete Docker Compose setup with all services. Create production variant with openidx.tdv.org domain configuration rather than rebuilding from scratch."
    },
    {
      "decision": "Deploy APISIX Gateway as primary ingress with SSL termination via certbot/Let's Encrypt",
      "rationale": "APISIX already configured in stack. Adding certbot for automatic SSL certificate management for openidx.tdv.org domain is the standard production approach."
    },
    {
      "decision": "Build production admin console with domain-specific VITE_ variables",
      "rationale": "React build is environment-specific. VITE_API_URL and VITE_OAUTH_URL must point to openidx.tdv.org for proper client-side API routing."
    },
    {
      "decision": "Implement nginx reverse proxy for SSL termination and static file serving",
      "rationale": "nginx provides robust SSL handling, static file caching for admin console assets, and reverse proxy capabilities for backend services."
    },
    {
      "decision": "Create production secrets management using .env.production file",
      "rationale": "Separate production secrets from development. Never commit production secrets to repository."
    },
    {
      "decision": "Implement health check endpoints for all services",
      "rationale": "Production deployments require service health monitoring for orchestration and alerting."
    },
    {
      "decision": "Configure PostgreSQL with persistent volumes and backup strategy",
      "rationale": "Data persistence is critical. Implement automated backups using existing backup scripts."
    }
  ],
  "backend_tasks": [
    {
      "order": 1,
      "file": "deployments/docker/docker-compose.prod.yml",
      "action": "create",
      "purpose": "Production Docker Compose configuration for openidx.tdv.org deployment",
      "key_functions": [
        "BaseServiceConfig",
        "ProductionOverrides",
        "DomainConfiguration"
      ]
    },
    {
      "order": 2,
      "file": "deployments/docker/.env.production",
      "action": "create",
      "purpose": "Production environment variables with secure secrets",
      "key_functions": [
        "ProductionSecrets",
        "DomainURLs",
        "DatabaseConfig"
      ]
    },
    {
      "order": 3,
      "file": "deployments/docker/nginx/nginx.conf",
      "action": "create",
      "purpose": "nginx SSL termination and reverse proxy configuration",
      "key_functions": [
        "SSLTermination",
        "AdminConsoleProxy",
        "APIGatewayProxy",
        "OAuthServiceProxy"
      ]
    },
    {
      "order": 4,
      "file": "deployments/docker/certbot-entrypoint.sh",
      "action": "create",
      "purpose": "Let's Encrypt certificate acquisition and renewal script",
      "key_functions": [
        "ObtainCertificate",
        "RenewCertificate",
        "ReloadNginx"
      ]
    },
    {
      "order": 5,
      "file": "deployments/docker/README.PRODUCTION.md",
      "action": "create",
      "purpose": "Production deployment documentation with step-by-step instructions",
      "key_functions": [
        "DeploymentSteps",
        "Troubleshooting",
        "ConfigurationReference"
      ]
    },
    {
      "order": 6,
      "file": "deployments/docker/load-production-routes.sh",
      "action": "create",
      "purpose": "APISIX route configuration for production domain",
      "key_functions": [
        "ConfigureProductionRoutes",
        "UpdateCORSOrigins",
        "SSLConfiguration"
      ]
    },
    {
      "order": 7,
      "file": "deploy/docker/health-monitor.go",
      "action": "create",
      "purpose": "Health monitoring service for production deployment",
      "key_functions": [
        "CheckAllServices",
        "ReportHealthMetrics",
        "AlertOnFailure"
      ]
    }
  ],
  "frontend_tasks": [
    {
      "order": 1,
      "file": "web/admin-console/.env.production",
      "action": "create",
      "purpose": "Production environment variables for admin console build",
      "key_functions": [
        "VITE_API_URL",
        "VITE_OAUTH_URL",
        "BuildConfiguration"
      ]
    },
    {
      "order": 2,
      "file": "web/admin-console/vite.config.ts",
      "action": "modify",
      "purpose": "Update build configuration for production deployment path",
      "key_functions": [
        "BasePathConfiguration",
        "AssetOptimization",
        "BuildOutput"
      ]
    },
    {
      "order": 3,
      "file": "web/admin-console/src/lib/api.ts",
      "action": "modify",
      "purpose": "Ensure API client uses production domain",
      "key_functions": [
        "GetAPIBaseURL",
        "GetOAuthURL",
        "ConfigureClient"
      ]
    },
    {
      "order": 4,
      "file": "deployments/docker/Dockerfile.admin-console",
      "action": "modify",
      "purpose": "Multi-stage build for production optimization",
      "key_functions": [
        "ProductionBuild",
        "AssetServing",
        "NginxConfiguration"
      ]
    },
    {
      "order": 5,
      "file": "web/admin-console/src/pages/landing.tsx",
      "action": "create",
      "purpose": "Production landing page for openidx.tdv.org",
      "key_functions": [
        "LandingPageComponent",
        "LoginRedirect",
        "FeatureShowcase"
      ]
    }
  ],
  "database_migrations": [
    {
      "file": "migrations/001_production_schema.up.sql",
      "sql": "ALTER TABLE users ADD COLUMN last_login_at TIMESTAMP; ALTER TABLE users ADD COLUMN login_count INTEGER DEFAULT 0; CREATE INDEX idx_users_email ON users(email); CREATE INDEX idx_sessions_user_id ON sessions(user_id); CREATE INDEX idx_audit_events_timestamp ON audit_events(created_at);"
    },
    {
      "file": "migrations/002_production_settings.up.sql",
      "sql": "CREATE TABLE production_settings (key VARCHAR(255) PRIMARY KEY, value TEXT, updated_at TIMESTAMP DEFAULT NOW()); INSERT INTO production_settings (key, value) VALUES ('domain', 'openidx.tdv.org'), ('ssl_enabled', 'true'), ('version', '1.0.0');"
    }
  ],
  "api_contracts": [
    {
      "method": "GET",
      "path": "/health",
      "request": {},
      "response": {
        "status": "healthy",
        "timestamp": "string",
        "services": {
          "postgres": "up",
          "redis": "up",
          "elasticsearch": "up"
        }
      },
      "status_codes": [
        200,
        503
      ]
    },
    {
      "method": "GET",
      "path": "/api/v1/identity/users/me",
      "request": {},
      "response": {
        "id": "uuid",
        "email": "user@example.com",
        "name": "John Doe",
        "roles": [
          "admin"
        ]
      },
      "status_codes": [
        200,
        401,
        403
      ]
    },
    {
      "method": "POST",
      "path": "/oauth/token",
      "request": {
        "grant_type": "password",
        "username": "string",
        "password": "string",
        "client_id": "string"
      },
      "response": {
        "access_token": "jwt",
        "token_type": "Bearer",
        "expires_in": 3600
      },
      "status_codes": [
        200,
        400,
        401
      ]
    }
  ],
  "test_plan": {
    "unit_tests": [
      {
        "file": "deployments/docker/health_test.go",
        "cases": [
          "HealthCheckReturns200",
          "AllServicesReportHealthy",
          "DegradedServiceDetected"
        ]
      },
      {
        "file": "internal/identity/service_auth_test.go",
        "cases": [
          "AuthenticateUser",
          "InvalidCredentialsRejected",
          "SessionCreatedOnAuth"
        ]
      }
    ],
    "e2e_tests": [
      {
        "name": "Production Login Flow",
        "steps": [
          "Navigate to https://openidx.tdv.org",
          "Enter credentials",
          "Submit login form",
          "Verify dashboard loads",
          "Verify session cookie set"
        ]
      },
      {
        "name": "Admin Console Access",
        "steps": [
          "Navigate to https://openidx.tdv.org",
          "Click admin login",
          "Authenticate as admin",
          "Verify admin console loads",
          "Test user management page"
        ]
      },
      {
        "name": "API Gateway Routing",
        "steps": [
          "Call GET /api/v1/identity/users",
          "Verify 200 response with user list",
          "Verify CORS headers present"
        ]
      },
      {
        "name": "SSL Certificate Validation",
        "steps": [
          "Check certificate is valid for openidx.tdv.org",
          "Verify certificate chain is complete",
          "Verify auto-renewal configured"
        ]
      }
    ]
  },
  "security_notes": [
    "Ensure JWT_SECRET is at least 32 bytes and randomly generated for production",
    "Set APP_ENV=production in all services",
    "Configure firewall to only allow ports 80, 443, 22 from external",
    "Enable PostgreSQL SSL connections (sslmode=require)",
    "Rotate secrets regularly using backup/restore scripts",
    "Configure rate limiting on APISIX to prevent DDoS",
    "Enable security headers via nginx: X-Frame-Options, X-Content-Type-Options, CSP"
  ],
  "docker_changes": [
    "Add certbot container for Let's Encrypt SSL certificate management",
    "Add nginx reverse proxy container for SSL termination",
    "Update admin-console environment to use openidx.tdv.org",
    "Configure APISIX to listen on localhost:9080 (behind nginx)",
    "Add persistent volume for Let's Encrypt certificates",
    "Update CORS origins to allow https://openidx.tdv.org",
    "Configure health check dependencies between services"
  ],
  "market_driven_features": [
    "Self-service user portal at /portal - password reset, profile management, MFA enrollment",
    "Risk-based authentication headers in access-service - X-Risk-Score for step-up auth",
    "Passwordless authentication via existing webauthn.go handlers",
    "MFA bypass codes for emergency access via existing mfa_bypass.go",
    "Device trust approval via existing device_trust_approval.go",
    "Active sessions management via existing Session model",
    "Adaptive MFA via existing adaptive_mfa.go"
  ]
}